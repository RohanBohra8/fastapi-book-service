from fastapi import APIRouter, status, Depends
from typing import List
from sqlalchemy.orm import Session
from fastapi.exceptions import HTTPException
from src.database import SessionLocal

from src.books.schemas import Book, BookUpdateModel
from src.books.models import Book as BookModel
from src.books.schemas import CreateBook
from src.books.models import Author as AuthorModel


book_router = APIRouter()

def get_db():
    with SessionLocal() as db:
        try:
            yield db
        finally:
            db.close()


# Get all books 
@book_router.get('/books', response_model=List[Book])
async def get_all_books(db: Session = Depends(get_db)):
    result = db.query(BookModel).all()
    return result

# Get a book by ID 
@book_router.get("/book/{book_id}", response_model=Book)
def get_book(book_id: int, db: Session = Depends(get_db)):
    result = db.query(BookModel).filter(BookModel.id == book_id).first()
    if not result:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Book not found with id: {book_id}")
    return result

# Create a book 
# book_data (schemas se check hota hai ki data sahi hai ya nahi)
@book_router.post("/books", status_code=status.HTTP_201_CREATED, response_model=Book)
def create_a_book(book_data: CreateBook, db: Session = Depends(get_db)):
    # ** this is dictionary unpacking -> when using this -> db model keys and schema class key must be same (spelling bhi)
    author = db.query(AuthorModel).filter(AuthorModel.id == book_data.author_id).first()
    if not author:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Author does not exist")
    
    new_book = BookModel(**book_data.model_dump(exclude={"id"}))  
    db.add(new_book)
    db.commit()
    db.refresh(new_book)  # Refresh to get the autogenerated ID
    return new_book

# Update a book 
@book_router.patch("/book/{book_id}", response_model=Book)
def update_book(book_id: int, book_update_data: BookUpdateModel, db: Session = Depends(get_db)):
    result = db.query(BookModel).filter(BookModel.id == book_id).first()
    if not result:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No book found to update")

    for key, value in book_update_data.model_dump(exclude_unset=True).items():
        setattr(result, key, value)

    db.commit()
    db.refresh(result)
    return result

# Delete a book 
@book_router.delete("/book/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_book(book_id: int, db: Session = Depends(get_db)):
    result = db.query(BookModel).filter(BookModel.id == book_id).first()
    if not result:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Book not found")

    db.delete(result)
    db.commit()

