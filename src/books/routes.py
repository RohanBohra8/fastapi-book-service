from fastapi import APIRouter, status, Depends
from typing import List
from sqlalchemy.orm import Session
from sqlalchemy.future import select
from fastapi.exceptions import HTTPException

from src.database import SessionLocal
from src.books.schemas import Book, BookUpdateModel
from src.books.models import Book as BookModel
from src.books.schemas import CreateBook


book_router = APIRouter()

# Dependency to get an async database session
def get_db():
    with SessionLocal() as db:
        try:
            yield db
        finally:
            db.close()


# ✅ Get all books (async)
@book_router.get('/books', response_model=List[Book])
async def get_all_books(db: Session = Depends(get_db)):
    # result = db.execute(select(BookModel))
    # books = result.scalars().all()
    result = db.query(BookModel).all()
    return result

# # ✅ Get a book by ID (async)
@book_router.get("/book/{book_id}", response_model=Book)
def get_book(book_id: int, db: Session = Depends(get_db)):
    # result = db.execute(select(BookModel).filter(BookModel.id == book_id))
    # book = result.scalar_one_or_none()
    result = db.query(BookModel).filter(BookModel.id == book_id).first()
    if not result:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Book not found with id: {book_id}")
    return result

# # ✅ Create a book (async)
# author exist validation todo
# book_data (schemas se check hota hai ki data sahi hai ya nahi)
@book_router.post("/books", status_code=status.HTTP_201_CREATED, response_model=Book)
def create_a_book(book_data: CreateBook, db: Session = Depends(get_db)):
    # ** this is dictionary unpacking -> when using this -> db model keys and schema class key must be same (spelling bhi)
    new_book = BookModel(**book_data.model_dump(exclude={"id"}))  # Exclude ID (autogenerated)
    db.add(new_book)
    db.commit()
    db.refresh(new_book)  # Refresh to get the autogenerated ID
    return new_book

# # ✅ Update a book (async)
@book_router.patch("/book/{book_id}", response_model=Book)
def update_book(book_id: int, book_update_data: BookUpdateModel, db: Session = Depends(get_db)):
    result = db.query(BookModel).filter(BookModel.id == book_id).first()
    # book = result.scalar_one_or_none()
    if not result:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No book found to update")

    for key, value in book_update_data.model_dump(exclude_unset=True).items():
        setattr(result, key, value)

    db.commit()
    db.refresh(result)
    return result

# # ✅ Delete a book (async)
@book_router.delete("/book/{book_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_book(book_id: int, db: Session = Depends(get_db)):
    result = db.query(BookModel).filter(BookModel.id == book_id).first()
    # book = result.scalar_one_or_none()
    if not result:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Book not found")

    db.delete(result)
    db.commit()


'''
#old
from fastapi import APIRouter, status
from typing import  List,Optional
from src.books.schemas import Book, BookUpdateModel
from fastapi.exceptions import HTTPException

from src.books.book_data import books


###
# i have used APIRouter() imported from fast api instead of FastApi()
# to create and use routers
# is is how the old one looked : book_router = FastAPI()
###

book_router = APIRouter()


# get all the books 
@book_router.get('/books', response_model = List[Book])
async def get_all_books():
    return books

# get a book by a specific book id 
@book_router.get("/book/{book_id}")
async def get_book(book_id:int) -> dict:
    for book in books:
        if book["id"] == book_id:
            return book
    
    raise HTTPException(status_code = status.HTTP_404_NOT_FOUND, detail = f"Book not found by given id : {book_id}")
   
# to create a book
@book_router.post("/books", status_code = status.HTTP_201_CREATED)
async def create_a_book(book_data:Book) -> dict:
    new_book = book_data.model_dump()
    books.append(new_book)
    return new_book

# update data in the specific book based on book_id
@book_router.patch("/book/{book_id}")
async def update_book(book_id: int, book_update_data : BookUpdateModel) -> dict:
    for book in books:
        if book["id"] == book_id:
            updated_data = book_update_data.model_dump(exclude_unset=True)  # Exclude fields that were not provided
            book.update(updated_data)  # Merge the new values into the existing book
            
            return book
    
    
    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail = "No Book found to update")


#need to ask for this error
# to delete a book from books
@book_router.delete("/book/{book_id}", status_code = status.HTTP_204_NO_CONTENT)
async def delete_book(book_id: int):
    for book in books:
        if book["id"] == book_id:
            books.remove(book)
            return 
    
    raise HTTPException(status_code = status.HTTP_404_NOT_FOUND, detail = "book not found")

'''